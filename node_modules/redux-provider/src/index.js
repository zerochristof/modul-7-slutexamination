// @flow

import Request from './request'
import React from 'react'

import {
  merge,
  forEach
} from 'lodash'

import {
  TransformRequest,
  TransformResponse,
} from './request/types'

import {
  Action,
  State,
  Payload,
  ComponentType
} from './store/states/types'

import {
  Defaults,
  Routine,
  Props,
} from './types'

import Store from 'angular-redux-middleware'

declare
var window: any

const {
  location
} = window

class Provider {
  constructor(props: Store) {
    const {
      basePath,
      token,
      type,
      path
    } = props
    const routines: Object<Routine> = {}
    const {
      store,
      source,
      request
    } = new Request(basePath, token, props)
    this.store = store;
    this.source = source;
    this.request = request;
    this.basePath = basePath;
    this.token = token;
    this.type = type;
    this.path = path;
    this.routines = routines
  }

  index = (routine: Routine, routineID = this.type) => {
    const route = routine
    const routineType = routineID
    this.routines[routineType] = route
    const routines = this.routines
    this.routines = routines
  }

  response: State = {}

  flagged: boolean = false

  serializeType = (resp: State) => {
    try {
      const respKeys = Object.keys(resp)
      const typeDefaultKeys = Object.keys(this.type.defaults)
      const typeOptionsKeys = Object.keys(this.type.options || {})
      const typeOptionsConditions = Object.keys(this.type.conditions || {})

      forEach(respKeys, (respKey) => {
        if (!typeDefaultKeys.includes(respKey)) {
          if (!typeOptionsKeys.includes(respKey)) {
            this.flagged = true
            throw new Error(`Provider Error: ${respKey} not found in this.type.`)
          } else {
            const index = typeOptionsKeys.indexOf(respKey)
            const keyType = typeof typeOptionsKeys(index)
            const respKeyType = typeof respKey
            if (keyType !== respKeyType) {
              const flag = true
              this.flagged = flag
              throw new Error(`Provider Error: Optional key ${respKey}::${respKeyType} does not match type ${keyType}.`)
            }
          }
        } else {
          const index = typeDefaultKeys.indexOf(respKey)
          const keyType = typeof typeDefaultKeys(index)
          const respKeyType = typeof respKey
          if (keyType !== respKeyType) {
            const flag = true
            this.flagged = flag
            throw new Error(`Provider Error: Default key ${respKey}::${respKeyType} does not match type ${keyType}.`)
          }
        }
      })

      if (!this.flagged) {
        const r = resp
        this.response = r
        return this.response
      } else {
        const r = false
        this.response = r
        return this.response
      }
    } catch (e) {
      console.log(e)
    }
  }

  call = async (action: Action, options: Defaults) => {
    const act = action
    const opts = options
    const {
      method = 'get',
      params = {},
      data = {},
      transformResponse
    } = opts
    const routine = this.routines[act.type]
    const url = `${this.basePath}${this.path.length > 1 ? `/${this.path}` : ''}`
    const serializedData = this.serializeType(data)
    const resp = await this.request(act, merge({
      url: url,
      method: method,
      params: params,
      data: serializedData,
      routine: routine,
      type: act.type,
    }, opts || {}))
    const r = transformResponse && transformResponse(resp, act.type) || resp
    const element = act.component ? React.cloneElement(act.component, r) : null
    this.response = r
    this.element = element
    return this.response
  }

  get = (action = {}, options = {}) => {
    options.method = 'get'
    const opts = options
    const act = action
    const call = this.call(act, opts)
    this.index(call)
  }

  post = (action = {}, options = {}) => {
    options.method = 'post'
    const opts = options
    const act = action
    const call = this.call(act, opts)
    this.index(call)
  }

  put = (action = {}, options = {}) => {
    options.method = 'put'
    const opts = options
    const act = action
    const call = this.call(act, opts)
    this.index(call)
  }

  patch = (action = {}, options = {}) => {
    options.method = 'patch'
    const opts = options
    const act = action
    const call = this.call(act, opts)
    this.index(call)
  }

  destroy = (action = {}, options = {}) => {
    options.method = 'delete'
    const opts = options
    const act = action
    const call = this.call(act, opts)
    this.index(call)
  }
}

export default Provider