'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var redux = require('redux');
var NESTED = /^([^.]*)\.(.+)$/;
var _______PING = '_______PING'; // ping is a "noop" action that is used to update subscribers when a child state is acted on.

var Action = (function () {
    function Action(pStore, pName, pFn) {
        _classCallCheck(this, Action);

        this.store = pStore;
        this.name = pName;
        this.fn = pFn;
        this._frozen = false;
    }

    _createClass(Action, [{
        key: 'update',
        value: function update(action, state) {
            return this.fn(action, state);
        }
    }]);

    return Action;
})();

var Store = (function () {
    function Store(initial) {
        _classCallCheck(this, Store);

        if (initial && !(typeof initial === 'object')) {
            throw new Error('must pass object to Store');
        }
        this.initial = initial || {};

        this._actions = new Map();
        this._unsubs = [];
        this.addAction(_______PING, function () {});
    }

    _createClass(Store, [{
        key: 'getState',
        value: function getState(raw) {
            return raw ? this.store.getState() : this.toJSON();
        }
    }, {
        key: 'clear',
        value: function clear(key) {
            this._actions['delete'](key);
        }
    }, {
        key: 'subscribe',
        value: function subscribe(handler) {
            var unsub = this.store.subscribe(handler);

            this._unsubs.push(unsub);
            return unsub;
        }

        /**
         * remove all the listeners to state change
         * recurse to any sub-states.
         */
    }, {
        key: 'destroy',
        value: function destroy() {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this._unsubs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var unsub = _step.value;

                    unsub();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            var state = this.getState(true);

            for (var prop in state) {
                if (state[prop] instanceof Store) {
                    state[prop].destroy();
                }
            }
            this._frozen = true;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            if (this._frozen) {
                return null;
            }

            var out = Object.assign({}, this.store.getState());
            for (var prop in out) {
                if (!(prop && out.hasOwnProperty(prop))) {
                    continue;
                }

                var value = out[prop];
                if (value instanceof Store) {
                    out[prop] = value.toJSON();
                }
            }

            return out;
        }
    }, {
        key: 'dispatch',
        value: function dispatch(action, pData, value) {
            if (this._frozen) {
                throw new Error('state is destroyed; can no longer dispatch');
            }
            var data = pData;
            if (typeof pData === 'string' && arguments.length > 2) {
                data = {};
                data[pData] = value;
            }
            var update;
            if (typeof action === 'string') {
                update = Object.assign({}, data, { type: action });
            } else if (action && typeof action === 'object') {
                update = action;
            } else {
                throw new Error('bad action');
            }

            if (NESTED.test(update.type)) {
                var match = NESTED.exec(update.type);
                var key = match[1];
                var nValue = this.getState(true)[key];
                if (nValue instanceof Store) {
                    var subType = match[2];
                    update.type = subType;
                    nValue.dispatch(update);
                    this.dispatch(_______PING); // to alert subsrcribers
                    return;
                }
            }
            this.store.dispatch(update);

            return this;
        }
    }, {
        key: 'addAction',
        value: function addAction(name, transformFn) {
            if (this._frozen) {
                throw new Error('state is destroyed; can no longer add actions');
            }
            var action = new Action(this, name, transformFn);
            this._actions.set(name, action);
            return this;
        }
    }, {
        key: 'stateFn',
        value: function stateFn() {
            var _this = this;

            return function (pState, action) {
                var start = Object.assign({}, pState || _this.initial);
                // cloning start state so that action updates cannot inadvertantly mutate the input

                if (_this._actions.has(action.type)) {
                    return Object.assign(start, _this._actions.get(action.type).update(start, action));
                } else {
                    return Object.assign(start);
                }
            };
        }
    }, {
        key: 'store',
        get: function get() {
            if (!this._store) {
                this._store = redux.createStore(this.stateFn());
            }

            return this._store;
        }
    }, {
        key: 'initial',
        set: function set(i) {
            this._initial = i;
        },
        get: function get() {
            return this._initial;
        }
    }]);

    return Store;
})();

exports['default'] = Store;
module.exports = exports['default'];